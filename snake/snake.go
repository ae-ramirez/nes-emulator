package main

import (
	"al/nes-emulator/cpu"
	"flag"
	"fmt"
	"image/color"
	"log"
	"math/rand"
	"os"
	"runtime/pprof"
	"time"
	"unsafe"

	"github.com/veandco/go-sdl2/sdl"
)

var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to file")

func main() {
	flag.Parse()
	if *cpuprofile != "" {
		f, err := os.Create(*cpuprofile)
		if err != nil {
			log.Fatal(err)
		}
		pprof.StartCPUProfile(f)
		defer pprof.StopCPUProfile()
	}

	gameCode := []uint8{
		0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9, 0x02, 0x85,
		0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85,
		0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe,
		0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20, 0x8d, 0x06, 0x20, 0xc3,
		0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9,
		0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60,
		0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0,
		0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01, 0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02,
		0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06,
		0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07,
		0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60, 0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06,
		0xb5, 0x11, 0xc5, 0x11, 0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c,
		0x35, 0x07, 0x60, 0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02,
		0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9,
		0x20, 0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
		0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10, 0xb0,
		0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29,
		0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60,
		0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10, 0x60, 0xa2, 0x00, 0xea,
		0xea, 0xca, 0xd0, 0xfb, 0x60,
	}

	c := &cpu.CPU{}
	c.LoadIntoLocation(gameCode, 0x0600)
	c.Reset()

	// init sdl2
	if err := sdl.Init(sdl.INIT_EVERYTHING); err != nil {
		panic(err)
	}
	defer sdl.Quit()

	window, err := sdl.CreateWindow("test", sdl.WINDOWPOS_UNDEFINED, sdl.WINDOWPOS_UNDEFINED,
		(32 * 10), (32 * 10), sdl.WINDOW_SHOWN)
	if err != nil {
		panic(err)
	}
	defer window.Destroy()

	renderer, err := sdl.CreateRenderer(window, -1, sdl.RENDERER_ACCELERATED)
	if err != nil {
		panic(fmt.Errorf("yo, %e", err))
	}
	defer renderer.Destroy()

	if err = renderer.SetScale(10.0, 10.0); err != nil {
		panic(fmt.Errorf("couldn't set scale, %e", err))
	}

	texture, err := renderer.CreateTexture(sdl.PIXELFORMAT_RGB24, sdl.TEXTUREACCESS_STATIC, 32, 32)
	if err != nil {
		panic(fmt.Errorf("no, %e", err))
	}
	pixels := make([]uint8, 32*32*3)

	c.RunWithCallback(func(*cpu.CPU) {
		// read user input and write it to mem[0xFF]
		handleUserInput(c)

		// update mem[0xFE] with new Random Number
		c.MemWrite(0xfe, uint8(rand.Intn(15)+1))

		// // read mem mapped screen state
		if readScreenState(c, pixels) {
			// render screen state
			texture.Update(nil, unsafe.Pointer(&pixels[0]), 32*3)
			renderer.Clear()
			renderer.Copy(texture, nil, nil)
			renderer.Present()
		}

		time.Sleep(time.Microsecond * 5)
	})

}

func handleUserInput(c *cpu.CPU) {
	for event := sdl.PollEvent(); event != nil; event = sdl.PollEvent() {
		switch t := event.(type) {
		case *sdl.KeyboardEvent:
			key := t.Keysym
			if t.State == sdl.PRESSED {
				if key.Sym == sdl.K_q {
					os.Exit(0)
				} else if key.Sym == sdl.K_f {
					c.MemWrite(0xff, 0x77)
				} else if key.Sym == sdl.K_s {
					c.MemWrite(0xff, 0x73)
				} else if key.Sym == sdl.K_r {
					c.MemWrite(0xff, 0x61)
				} else if key.Sym == sdl.K_t {
					c.MemWrite(0xff, 0x64)
				}
			}
		}
	}

}

func readScreenState(c *cpu.CPU, screenState []uint8) bool {
	frameIdx := 0
	update := false

	for i := 0x0200; i < 0x0600; i++ {
		colorIdx := c.MemRead(uint16(i))
		b1, b2, b3 := colorByte(colorIdx)
		if screenState[frameIdx] != uint8(b1) || screenState[frameIdx+1] != uint8(b2) || screenState[frameIdx+2] != uint8(b3) {
			screenState[frameIdx] = uint8(b1)
			screenState[frameIdx+1] = uint8(b2)
			screenState[frameIdx+2] = uint8(b3)
			update = true
		}
		frameIdx += 3
	}

	return update
}

func colorByte(byte uint8) (r uint8, g uint8, b uint8) {
	switch byte {
	case 0: // black
		return 0x0, 0x0, 0x0
	case 1: // white
		return 0xff, 0xff, 0xff
	case 2, 9:
		return 0x12, 0x65, 0xf0
	case 3, 10:
		return 0xff, 0x0, 0x0
	case 4, 11:
		return 0x0, 0xff, 0x0
	case 5, 12:
		return 0x0, 0x0, 0xff
	case 6, 13:
		return 0x0f, 0x0f, 0xff
	case 7, 14:
		return 0x0f, 0x0f, 0x0
	default:
		return 0x12, 0x0f, 0x82
	}
}
